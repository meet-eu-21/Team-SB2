<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>HiCtoolbox API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>HiCtoolbox</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#python 3
#2019-2020
#CC-By-SA
#Old code from Carron Leopold
#Modified by Damien Legros, CÃ©dric Cornede, Arnaud Quelin, Rouquaya Mouss, Hamid Hachemi

#####
#Imports

import os
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from scipy import sparse
from scipy import stats
from scipy.spatial import distance
from tqdm import tqdm
from hmmlearn import hmm
from sklearn.manifold import TSNE
from sklearn.decomposition import KernelPCA
import umap
import seaborn as sns

np.seterr(divide = &#39;ignore&#39;) 

#####
#ADDITIONAL LOADER

def EpiGbyres(EpiGfilename,res,achr,sizeatres,NbEpi):
        &#34;&#34;&#34;
        Generate a matrix of repartition of epiG in a chr at the given resolution
        Do it the hard way : parse the file to the desired resolution directly
        
        Entries : EpiGfilename -&gt; String
                  res -&gt; int
                  achr -&gt; int
                  sizeatres -&gt; int
                  NbEpi -&gt; int
        Return : Epimat -&gt; list
        &#34;&#34;&#34;
        Epimat=np.zeros((NbEpi,sizeatres))
        o=open(EpiGfilename,&#39;r&#39;)
        l=o.readline()
        while l:
                ls=l.split()
                if ls[0]==achr:
                        #force to scale bp cover in bin cover here
                        EpiV=int(ls[3])-1
                        b=np.float(ls[1])
                        e=np.float(ls[2])
                        begin=int(np.floor(b/res)) #force to cast for indexing error
                        end=int(np.floor(e/res)) #force to cast for indexing error
                        eC=end*res
                        bC=begin*res
                        val=1
                        if begin==end: #1 bin
                                Epimat[EpiV,begin]+=val*(e-b)
                        else:
                                if (end-begin)==1: #2 bin
                                        Epimat[EpiV,begin]+=val*(eC-b)
                                        Epimat[EpiV,end]+=val*(e-eC)
                                else: #more than 2 bin
                                        Epimat[EpiV,begin]+=val*(res-(b-bC))
                                        while begin&lt;end:
                                                Epimat[EpiV,begin]+=val*res
                                                begin+=1
                                        if (e-eC)&gt;0:
                                                Epimat[EpiV,begin]+=val*(e-eC) #here begin=end
                l=o.readline()
        o.close()
        return Epimat

#####
#Building tools

def buildMatrix(HiCfilename, printer=True):
    &#34;&#34;&#34;
    Build the matrix from the HiC data
    
    Entries : HiCfilename -&gt; String
              printer -&gt; boolean
    Return : A -&gt; list
    &#34;&#34;&#34;
    if printer:
        bar = tqdm(range(1), desc=&#34;Loading Matrix &#34;)
    else:
        bar = range(1)

    for i in bar:
        pass
    try:
        A=np.loadtxt(HiCfilename)
        A=np.int_(A)
    except:
        print(&#34;Data was not correctly downloaded, please delete the folder and relaunch the main.py&#34;)
    
    #Build array at pb resolution
    A=np.concatenate((A,np.transpose(np.array([A[:,1],A[:,0],A[:,2]]))), axis=0)
    A = sparse.coo_matrix( (A[:,2], (A[:,0],A[:,1])))
    return A

def buildColors(EpiGfilename, chromosome_number, LENTEST, printer=True):
        &#34;&#34;&#34;
        Build the colors for the epigenetic marks
        
        Entries : HiCfilename -&gt; String
                  chromosome_number -&gt; int
                  LENTEST -&gt; int
                  printer -&gt; boolean
        Return : color_vec -&gt; list
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Loading Colors &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass
        color=pd.read_csv(EpiGfilename,delimiter=&#39;\t&#39;,header=None,names=[1,2,3,4])
        #Take only chr of interest
        color=color[color[1]==chromosome_number]
        #Number of color in the file
        number=color[4].max()
        #Build array at pb resolution LENchr * number of color
        color_vec=np.zeros((LENTEST,number+1), dtype=&#39;uint8&#39;) 
        i=0
        while i&lt;np.shape(color)[0]:
                color_vec[color[2].iloc[i]:color[3].iloc[i],color[4].iloc[i]]=1
                i+=1
        return color_vec

#####
#Plotting tools

def plotter(data2D, nameFig=&#34;Plot&#34;, plotType=&#34;Matrix&#34;, cmap=&#34;hot_r&#34;, vmin=None, vmax=None, jupyter=False, nameFile=&#34;Plot.pdf&#34;, centro_start=None, centro_end=None, Data_type=&#39;Contact&#39;):
    &#34;&#34;&#34;
    Plotter used in the analysis
    
    Entries : data2D -&gt; list
              nameFig -&gt; String
              plotType -&gt; String
              cmap -&gt; String
              vmin -&gt; float
              vmax -&gt; float
              jupyter -&gt; boolean
              nameFile -&gt; String
              centro_start -&gt; int
              centro_end -&gt; int
              Data_type -&gt; String
    
    Make the various following plots :
    - Matrix plot
    - AB Compartments plot
    - Density plot
    - HMM Score plot
    - All Results plot
    &#34;&#34;&#34;
    if plotType == &#34;Matrix&#34;:
        custom_params = {&#34;axes.spines.right&#34;: False, 
                         &#34;axes.spines.top&#34;: False}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)
        fig = plt.figure()
        fig.set_dpi(300)
        im = plt.imshow(data2D, cmap=cmap, vmin=vmin, vmax=vmax)
        plt.colorbar(im, drawedges=False)
        plt.xlabel(&#34;Position&#34;)
        plt.ylabel(&#34;Position&#34;)
        plt.title(nameFig)

    elif plotType == &#34;AB&#34;:
        custom_params = {&#34;axes.spines.right&#34;: False, 
                         &#34;axes.spines.top&#34;: False,}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)
        x = np.arange(0.0, np.shape(data2D)[0], 1)
        y = data2D
        fig, ax = plt.subplots()
        fig.set_dpi(300)
        ax.fill_between(x, y, where=(data2D&gt;0), color=&#39;red&#39;)
        ax.axhline(0, color=&#34;black&#34;, linewidth=0.75)
        ax.fill_between(x, y, where=(data2D&lt;0), color=&#39;blue&#39;)
        plt.axvspan(centro_start, centro_end, facecolor=&#39;red&#39;, alpha=0.2)
        plt.xlabel(&#34;Position&#34;)
        plt.ylabel(&#34;Activation&#34;)
        plt.title(nameFig)

    elif plotType == &#34;Density&#34;: #Density plot
        custom_params = {&#34;axes.spines.right&#34;: False, 
                         &#34;axes.spines.top&#34;: False}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)
        x = np.arange(0,len(data2D))
        y = data2D
        fig = plt.figure()
        fig.set_dpi(300)
        plt.plot(x, y, color=&#39;blue&#39;, alpha=1, linewidth=0.1)
        plt.axvspan(centro_start, centro_end, facecolor=&#39;red&#39;, alpha=0.2)
        plt.xlabel(&#34;Position&#34;)
        plt.ylabel(&#34;Density&#34;)
        plt.title(nameFig)

    elif plotType == &#34;HMMScore&#34;:
        custom_params = {&#34;axes.spines.right&#34;: False, &#34;axes.spines.top&#34;: False}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)
        x = np.arange(2,16)
        y = data2D
        fig = plt.figure()
        fig.set_dpi(300)
        plt.plot(x, y, color=&#39;blue&#39;, alpha=0.4)
        best = 2
        if (Data_type==&#39;Contact&#39;):
            threshold = 1
        elif Data_type==&#39;Epigenetic&#39;:
            threshold = 0.5
        for i in range(1,len(data2D)):
            temp = ((data2D[i]-data2D[i-1])/np.abs(data2D[i]))*100
            if temp &gt;= threshold:
                best += 1
            else: 
                break
        plt.scatter(best, data2D[best-2], alpha=1, color=&#39;red&#39;, label=&#34;predicted number of compartments : &#34; + str(best))
        plt.xlabel(&#34;Number of compartments&#34;)
        plt.ylabel(&#34;HMM Score&#34;)
        plt.legend(loc=&#39;upper left&#39;)
        plt.title(nameFig)

    elif plotType == &#34;Barcode&#34;:
        custom_params = {&#34;axes.spines.left&#34;: False, 
                         &#34;axes.spines.right&#34;: False, 
                         &#34;axes.spines.top&#34;: False}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)
        pixel_per_bar = 1
        dpi = 100
        fig = plt.figure(figsize=(len(data2D) * pixel_per_bar / dpi, 2))
        fig.set_dpi(300)
        ax = fig.add_axes([0, 0, 1, 1])
        ax.imshow(data2D.reshape(1, -1), cmap=&#39;bwr&#39;, aspect=&#39;auto&#39;, interpolation=&#39;nearest&#39;)
        ax.axes.get_yaxis().set_visible(False)
        plt.xlabel(&#34;Position&#34;)
        plt.title(nameFig)

    elif plotType == &#34;Visualization&#34;:
        [barcode, corr, density] = data2D
        fig = plt.figure(constrained_layout=True)
        fig.set_dpi(300)
        gs = fig.add_gridspec(ncols=2, 
                              nrows=2,
                              width_ratios=[10, 6.25], 
                              wspace=0.,
                              hspace=0., 
                              height_ratios=[1, 13])
        custom_params = {&#34;axes.spines.right&#34;: False, 
                         &#34;axes.spines.top&#34;: False}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)

        #Barcode
        f_ax1 = fig.add_subplot(gs[0, 0])
        f_ax1.set_xlim([0,np.shape(barcode)[0]])
        f_ax1.grid(False)
        f_ax1.set(yticklabels=[], xticklabels=[])
        f_ax1.tick_params(left=False, right=False)
        x = np.arange(0, np.shape(barcode)[0], 1)
        f_ax1.set_title(nameFig, x=0.5, y=1.2)
        f_ax1.imshow(barcode.reshape(1, -1), cmap=&#39;bwr&#39;, aspect=&#39;auto&#39;, interpolation=&#39;nearest&#39;)

        #Correlation Matrix
        f_ax2 = fig.add_subplot(gs[1, 0])
        im = f_ax2.imshow(corr, cmap=&#39;seismic&#39;, vmin=-np.amax(corr), vmax=np.amax(corr))
        f_ax2.grid(False)
        plt.colorbar(im, location=&#39;left&#39;)

        #Gene density
        f_ax3 = fig.add_subplot(gs[1, 1])
        f_ax3.axis(&#39;off&#39;)
        x = density
        y = np.flip(np.arange(0,np.shape(density)[0]))
        f_ax3.axhspan(np.shape(density)[0]-centro_start, np.shape(density)[0]-centro_end, facecolor=&#39;red&#39;, alpha=0.2)
        f_ax3.plot(x, y, color=&#39;blue&#39;, alpha=1, linewidth=0.1)

    if jupyter:
        plt.show()
    else:
        plt.savefig(nameFile)
    plt.clf()

#####
#Filtering tools

def filtering(Hicmat,factor=1.5, printer=True):
        &#34;&#34;&#34;
        Filter the matrix and return the matrix filtered and the list of indexs removed
        
        Entries : Hicmat -&gt; list
                  factor -&gt; float
                  printer -&gt; boolean
        Return : Hicmatreduce -&gt; list
                 segmenter1 -&gt; list
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Filtering &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass

        Filterextremum=True
        Hicmatreduce=Hicmat
        #first step : filter empty bin
        sumHicmat=Hicmat.sum(axis = 0)
        segmenter1=sumHicmat&gt;0
        A=np.where(segmenter1)
        Hicmatreduce=Hicmatreduce[A[1],:]
        Hicmatreduce=Hicmatreduce[:,A[1]]
        if Filterextremum:
                #second step : filter lower bin
                sumHicmat=np.sum(Hicmatreduce,0)
                msum=np.mean(sumHicmat)
                mstd=np.std(sumHicmat)
                mini = msum-mstd*factor
                maxi = msum+mstd*factor
                #Make the bolean condition
                newcond=mini &lt; sumHicmat
                newcond2=sumHicmat &lt; maxi
                newcond=np.logical_and(newcond,newcond2)
                B=np.where(newcond)
                #Filter
                Hicmatreduce=Hicmatreduce[B[1],:]
                Hicmatreduce=Hicmatreduce[:,B[1]]
                segmenter1=A[1][B[1]] #Create the binsaved index
        return Hicmatreduce,segmenter1
        
def unfiltering(binsaved, contact_map, shape, printer=True):
        &#34;&#34;&#34;
        Unfilter the matrix and return the matrix unfiltered
        
        Entries : binsaved -&gt; list
                  contact_map -&gt; list
                  shape -&gt; list
                  printer -&gt; boolean
        Return : unfiltered_map -&gt; list
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Unfiltering &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass

        unfiltered_map = contact_map
        binunsaved = []
        for i in range(shape[0]):
                if ((i in binsaved) == False):
                        binunsaved.append(i)
        for i in binunsaved:
                unfiltered_map = np.insert(unfiltered_map, i, 0, axis= 0)
                unfiltered_map = np.insert(unfiltered_map, i, 0, axis= 1)
        return unfiltered_map


#####
#Binning tools

def bin2d(Data,p,q, printer=True):    
        &#34;&#34;&#34;   
        Data = input matrix
        p,q rescaling factors
        Written for sparse 
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Changing Resolution &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass

        n,m=np.shape(Data);
        s=(int(np.ceil(n/p)),int(np.ceil(m/q)))
        i,j,d = sparse.find(Data);
        i=np.int_(np.ceil(i/p))
        j=np.int_(np.ceil(j/q))
        M=sparse.csr_matrix((d,(i,j)))
        return M

def bin1D(anumpyarray, resolutionfrom, resolutionto):
        &#34;&#34;&#34;
        in : A numpy array , number of bin in raw and in col
        out : the matrix binned
        &#34;&#34;&#34;
        print(resolutionto,resolutionfrom)
        if resolutionto&gt;resolutionfrom:
                convertionfactor=np.ceil(resolutionto/resolutionfrom)
                s=anumpyarray.shape
                print(&#34;dimension du vecteur:&#34;,s)
                #has to be identical as result in other function like chrsizedict)
                newsizei=np.ceil(s[0]*resolutionfrom/resolutionto)
                newarray=np.zeros(int(newsizei))
                print(&#34;taille du vecteur appres rescale :&#34;,newarray.shape)
                i=0
                while i&lt;newsizei:
                        ifrom=int(i*convertionfactor)
                        ito=int((i+1)*convertionfactor)
                        if i==newsizei-1:
                                asum=np.sum(anumpyarray[ifrom:])
                        else:
                                asum=np.sum(anumpyarray[ifrom:ito])
                        newarray[i]=asum
                        i+=1
                return newarray
        elif resolutionto==resolutionfrom:
                print(&#34;no binning&#34;)
                return anumpyarray
        else:
                print(&#34;wrong resolution parameter in bin1D&#34;)

def bin2dfullmat(anumpyarray, resolutionfrom, resolutionto):
        &#34;&#34;&#34;
        in : A numpy array , number of bin in raw and in col
        out : the matrix binned
        Written for full
        &#34;&#34;&#34;
        print(&#39;change of resolution from &#39;,resolutionfrom,&#39; to &#39;,resolutionto)
        if resolutionto&gt;resolutionfrom:
                convertionfactor=np.ceil(resolutionto/resolutionfrom)
                s=anumpyarray.shape
                print(&#34;Initial HiC size before binning:&#34;,s)
                #has to be identical as result in other function like chrsizedict)
                newsizei=np.ceil(s[0]*resolutionfrom/resolutionto)
                newsizej=np.ceil(s[1]*resolutionfrom/resolutionto)
                newarray=np.zeros((int(newsizei),int(newsizej)))
                print(&#34;HiC size after binning :&#34;,newarray.shape)
                i=0
                j=0
                while i&lt;newsizei:
                        while j&lt;newsizej:
                                ifrom=int(i*convertionfactor)
                                ito=int((i+1)*convertionfactor)
                                jfrom=int(j*convertionfactor)
                                jto=int((j+1)*convertionfactor)
                                if i==newsizei-1:
                                        asum=np.sum(anumpyarray[ifrom:,jfrom:jto])
                                elif j==newsizej-1:
                                        asum=np.sum(anumpyarray[ifrom:ito,jfrom:])
                                elif i==newsizei-1 and j==newsizej-1:
                                        asum=np.sum(anumpyarray[ifrom:,jfrom:])
                                else:
                                        asum=np.sum(anumpyarray[ifrom:ito,jfrom:jto])
                                newarray[i,j]=asum
                                newarray[j,i]=asum
                                j+=1
                        i+=1
                        j=0
                return newarray
        elif resolutionto==resolutionfrom:
                print(&#34;No binning&#34;)
                return anumpyarray
        else:
                print(&#34;Wrong resolution parameter&#34;)


#####
#Operations tools

def SVD(D):
        &#34;&#34;&#34;
        Calculate the SVD and return the first eigenvector
        
        out : SVD(D)
        &#34;&#34;&#34; 
        eigens_values,eigens_vectors = np.linalg.eig(D)
        return eigens_vectors[:,0]

def Corr(D, printer=True):
        &#34;&#34;&#34;
        Calculate the pearson correlation and return the matrix
        
        out : Corr(D)
        &#34;&#34;&#34; 
        lines, columns = np.shape(D)
        C = np.zeros((lines, columns))

        if printer:
                bar = tqdm(range(lines), desc=&#34;Pearson Correlation &#34;)
        else:
                bar = range(lines)

        for i in bar:
                for j in range(columns):
                        C[i, j] = stats.pearsonr(D[i, :], D[:, j])[0]
        return C
        
def OE(D, printer=True):
        &#34;&#34;&#34;
        Calculate the OE matrix and return it
        out : OE(D)
        &#34;&#34;&#34;  
        i=0
        j=0
        L=len(D)

        if printer:
                bar = tqdm(range(1), desc=&#34;O/E &#34;)
        else:
                bar = range(1)
        
        for i in bar:
                pass
                
        while j&lt;L:
                thediag=np.diag(D,k=j)
                mtg=np.mean(thediag)
                if mtg == 0:
                        mtg = 1e-8
                while i&lt;(L-j):
                        v=D[i,i+j]/mtg
                        D[i,i+j]=v
                        D[i+j,i]=v
                        i+=1
                i=0
                j+=1
        return D

def SCN(D, max_iter = 10, printer=True):
        &#34;&#34;&#34;
        Calculate the SCN and return it
        Out  : SCN(D)
        Code version from Vincent Matthys
        &#34;&#34;&#34;    
        # Iteration over max_iter

        if printer:
                bar = tqdm(range(max_iter), desc=&#34;SCN &#34;)
        else:
                bar = range(max_iter)

        for i in bar:        
                D /= np.maximum(1, D.sum(axis = 0))       
                D /= np.maximum(1, D.sum(axis = 1))    
                # To make matrix symetric again   
        return (D + D.T)/2 

def fastFloyd(contact, printer=True):
        &#34;&#34;&#34;
        out : FF(contact)
        Code version from Vincent Matthys
        &#34;&#34;&#34;      
        n = contact.shape[0]    
        shortest = contact    

        if printer:
                bar = tqdm(range(n), desc=&#34;Fast Floyd &#34;)
        else:
                bar = range(n)

        for k in bar:        
                i2k = np.tile(shortest[k,:], (n, 1))        
                k2j = np.tile(shortest[:, k], (n, 1)).T        
                shortest = np.minimum(shortest, i2k + k2j)    
        return shortest


def filteramat(Hicmat, Filterextremum=True, factor=1.5, printer=True):
        &#34;&#34;&#34;
        in : a HiCmat without any transformation, factor of reduction
        out : the HiCmatreduce,thevector of his transformation
        THE filter part from the main in one function
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Matrix Filtering &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass
        Hicmatreduce=Hicmat
        #first step : filter empty bin
        sumHicmat=Hicmat.sum(axis = 0)
        segmenter1=sumHicmat&gt;0
        A=np.where(segmenter1)
        Hicmatreduce=Hicmatreduce[A[1],:]
        Hicmatreduce=Hicmatreduce[:,A[1]]
        if Filterextremum:
                #second step : filter lower bin
                sumHicmat=np.sum(Hicmatreduce,0)
                msum=np.mean(sumHicmat)
                mstd=np.std(sumHicmat)
                mini = msum-mstd*factor
                maxi = msum+mstd*factor
                #Make the bolean condition
                newcond=mini &lt; sumHicmat
                newcond2=sumHicmat &lt; maxi
                newcond=np.logical_and(newcond,newcond2)
                B=np.where(newcond)
                #Filter
                Hicmatreduce=Hicmatreduce[B[1],:]
                Hicmatreduce=Hicmatreduce[:,B[1]]
                segmenter1=A[1][B[1]] #Create the binsaved index
        return Hicmatreduce,segmenter1


def sammon(x, n, display = 2, inputdist = &#39;raw&#39;, maxhalves = 20, maxiter = 500, tolfun = 1e-9, init = &#39;default&#39;):


    &#34;&#34;&#34;Perform Sammon mapping on dataset x

    y = sammon(x) applies the Sammon nonlinear mapping procedure on
    multivariate data x, where each row represents a pattern and each column
    represents a feature.  On completion, y contains the corresponding
    co-ordinates of each point on the map.  By default, a two-dimensional
    map is created.  Note if x contains any duplicated rows, SAMMON will
    fail (ungracefully). 

    [y,E] = sammon(x) also returns the value of the cost function in E (i.e.
    the stress of the mapping).

    An N-dimensional output map is generated by y = sammon(x,n) .

    A set of optimisation options can be specified using optional
    arguments, y = sammon(x,n,[OPTS]):

       maxiter        - maximum number of iterations
       tolfun         - relative tolerance on objective function
       maxhalves      - maximum number of step halvings
       input          - {&#39;raw&#39;,&#39;distance&#39;} if set to &#39;distance&#39;, X is 
                        interpreted as a matrix of pairwise distances.
       display        - 0 to 2. 0 least verbose, 2 max verbose.
       init           - {&#39;pca&#39;, &#39;cmdscale&#39;, random&#39;, &#39;default&#39;}
                        default is &#39;pca&#39; if input is &#39;raw&#39;, 
                        &#39;msdcale&#39; if input is &#39;distance&#39;

    The default options are retrieved by calling sammon(x) with no
    parameters.

    File        : sammon.py
    Date        : 18 April 2014
    Authors     : Tom J. Pollard (tom.pollard.11@ucl.ac.uk)
                : Ported from MATLAB implementation by 
                  Gavin C. Cawley and Nicola L. C. Talbot

    Description : Simple python implementation of Sammon&#39;s non-linear
                  mapping algorithm [1].

    References  : [1] Sammon, John W. Jr., &#34;A Nonlinear Mapping for Data
                  Structure Analysis&#34;, IEEE Transactions on Computers,
                  vol. C-18, no. 5, pp 401-409, May 1969.

    Copyright   : (c) Dr Gavin C. Cawley, November 2007.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

    &#34;&#34;&#34;

    # Create distance matrix unless given by parameters
    if inputdist == &#39;distance&#39;:
        D = x
        if init == &#39;default&#39;:
            init = &#39;cmdscale&#39;
    else:
        D = distance.cdist(x, x)
        if init == &#39;default&#39;:
            init = &#39;pca&#39;

    if inputdist == &#39;distance&#39; and init == &#39;pca&#39;:
        raise ValueError(&#34;Cannot use init == &#39;pca&#39; when inputdist == &#39;distance&#39;&#34;)

    if np.count_nonzero(np.diagonal(D)) &gt; 0:
        raise ValueError(&#34;The diagonal of the dissimilarity matrix must be zero&#34;)

    # Remaining initialisation
    N = x.shape[0]
    scale = 0.5 / D.sum()
    D = D + np.eye(N)     

    if np.count_nonzero(D&lt;=0) &gt; 0:
        raise ValueError(&#34;Off-diagonal dissimilarities must be strictly positive&#34;)   

    Dinv = 1 / D
    if init == &#39;pca&#39;:
        [UU,DD,_] = np.linalg.svd(x)
        y = UU[:,:n]*DD[:n] 
    elif init == &#39;cmdscale&#39;:
        from cmdscale import cmdscale
        y,e = cmdscale(D)
        y = y[:,:n]
    else:
        y = np.random.normal(0.0,1.0,[N,n])
    one = np.ones([N,n])
    d = distance.cdist(y,y) + np.eye(N)
    dinv = 1. / d
    delta = D-d 
    E = ((delta**2)*Dinv).sum()

    # Get on with it
    for i in range(maxiter):

        # Compute gradient, Hessian and search direction (note it is actually
        # 1/4 of the gradient and Hessian, but the step size is just the ratio
        # of the gradient and the diagonal of the Hessian so it doesn&#39;t
        # matter).
        delta = dinv - Dinv
        deltaone = np.dot(delta,one)
        g = np.dot(delta,y) - (y * deltaone)
        dinv3 = dinv ** 3
        y2 = y ** 2
        H = np.dot(dinv3,y2) - deltaone - np.dot(2,y) * np.dot(dinv3,y) + y2 * np.dot(dinv3,one)
        s = -g.flatten(order=&#39;F&#39;) / np.abs(H.flatten(order=&#39;F&#39;))
        y_old    = y

        # Use step-halving procedure to ensure progress is made
        for j in range(maxhalves):
            s_reshape = np.reshape(s, (-1,n),order=&#39;F&#39;)
            y = y_old + s_reshape
            d = distance.cdist(y, y) + np.eye(N)
            dinv = 1 / d
            delta = D - d
            E_new = ((delta**2)*Dinv).sum()
            if E_new &lt; E:
                break
            else:
                s = 0.5*s

        # Bomb out if too many halving steps are required
        if j == maxhalves-1:
            print(&#39;Warning: maxhalves exceeded. Sammon mapping may not converge...&#39;)

        # Evaluate termination criterion
        if abs((E - E_new) / E) &lt; tolfun:
            if display:
                print(&#39;TolFun exceeded: Optimisation terminated&#39;)
            break

        # Report progress
        E = E_new
        if display &gt; 1 and printer:
            print(&#39;epoch = %d : E = %12.10f&#39;% (i+1, E * scale))

    if i == maxiter-1:
        print(&#39;Warning: maxiter exceeded. Sammon mapping may not have converged...&#39;)

    # Fiddle stress to match the original Sammon paper
    E = E * scale
    
    return [y,E]

#####
#Predicting sub-compartments tools

def gaussianHMM(vector, nb_comp=2, n_iter=100):
        &#34;&#34;&#34;
        generate a simple hmm to have compartment on correlation map
        Return the model of the hmm and the states of the prediction at given N
        
        Entries : vector -&gt; list
                  nb_comp -&gt; int
                  n_iter -&gt; int
        Return : labels_list -&gt; list
                 scores_list -&gt; list
        &#34;&#34;&#34;
        # Run Gaussian HMM
        model = hmm.GaussianHMM(nb_comp, &#34;tied&#34;,n_iter=n_iter)
        model.fit(vector)
        labels = model.predict(vector) #etats/compartiments
        score = model.score(vector)

        return labels, score

def multiplegaussianHMM(vector, nb_comp_max=16, n_iter=100):
        &#34;&#34;&#34;
        generate the hmms of each compartment on correlation map
        Return the model of all hmm and the states of the prediction at given N
        
        Entries : vector -&gt; list
                  nb_comp_max -&gt; int
                  n_iter -&gt; int
        Return : labels_list -&gt; list
                 scores_list -&gt; list
        &#34;&#34;&#34;
        labels_list = []
        scores_list = []
        for i in tqdm (range(2, nb_comp_max), desc=&#34;Finding Compartments with HMM &#34;):
                labels, score = gaussianHMM(vector, i, n_iter=n_iter)
                labels_list.append(labels)
                scores_list.append(score)

        return labels_list, scores_list

def expr_repr_scoring(color_bins, marks, scores):
        &#34;&#34;&#34;
        Calculate the expression repression score and return it
        
        Entries : color_bins -&gt; list
                  marks -&gt; list
                  scores -&gt; list
        Return : float
        &#34;&#34;&#34;
        output = color_bins[:,0].toarray() #only zeros
        for i in range(len(marks)):
                mark = marks[i]
                score = scores[i]
                X = color_bins[:,mark].toarray()
                output+=X*score

        return output

def similarity_score(val_data, data):
        &#34;&#34;&#34;
        Calculate the similarity score and return it
        
        Entries : val_data -&gt; list
                  data -&gt; list
        Return : float
        &#34;&#34;&#34;
        cnt = 0
        for i in range(np.shape(data)[0]):
                if val_data[i] == data[i]:
                        cnt += 1

        similarity = cnt/np.shape(data)[0] * 100
        
        return round(similarity, 3)

#####
#PDB maker tool


def writePDB(fnameout, value, EpiValue, printer=True):
        &#34;&#34;&#34;
        Write a PDB file from values
        
        Entries : fnameout -&gt; String
                  value -&gt; int
                  EpiValue -&gt; list  
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Writing PDB &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass
        Sh=np.shape(value)
        #out
        fout=open(fnameout,&#39;w&#39;)
        i=1
        while i&lt;=Sh[0]:
                S=&#34;{:6s}{:5d} {:^4s}{:1s}{:3s} {:1s}{:4d}{:1s}   {:8.3f}{:8.3f}{:8.3f}{:6.2f}{:6.2f}          {:&gt;2s}{:2s}&#34; #PDB format in python
                #print(&#34;here&#34;,value[i-1,0],value[i-1,1],EpiValue[i-1])
                S=S.format(&#39;ATOM&#39;,i,&#39;CA&#39;,&#39;&#39;,&#39;ALA&#39;,&#39;A&#39;,i,&#39;&#39;,float(value[i-1,0]),float(value[i-1,1]),float(value[i-1,2]),1,float(EpiValue[i-1]),&#39;C&#39;,&#39;&#39;)
                #print(S)
                fout.write(S+&#34;\n&#34;)
                i+=1
        fout.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="HiCtoolbox.Corr"><code class="name flex">
<span>def <span class="ident">Corr</span></span>(<span>D, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pearson correlation and return the matrix</p>
<p>out : Corr(D)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Corr(D, printer=True):
        &#34;&#34;&#34;
        Calculate the pearson correlation and return the matrix
        
        out : Corr(D)
        &#34;&#34;&#34; 
        lines, columns = np.shape(D)
        C = np.zeros((lines, columns))

        if printer:
                bar = tqdm(range(lines), desc=&#34;Pearson Correlation &#34;)
        else:
                bar = range(lines)

        for i in bar:
                for j in range(columns):
                        C[i, j] = stats.pearsonr(D[i, :], D[:, j])[0]
        return C</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.EpiGbyres"><code class="name flex">
<span>def <span class="ident">EpiGbyres</span></span>(<span>EpiGfilename, res, achr, sizeatres, NbEpi)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a matrix of repartition of epiG in a chr at the given resolution
Do it the hard way : parse the file to the desired resolution directly</p>
<p>Entries : EpiGfilename -&gt; String
res -&gt; int
achr -&gt; int
sizeatres -&gt; int
NbEpi -&gt; int
Return : Epimat -&gt; list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EpiGbyres(EpiGfilename,res,achr,sizeatres,NbEpi):
        &#34;&#34;&#34;
        Generate a matrix of repartition of epiG in a chr at the given resolution
        Do it the hard way : parse the file to the desired resolution directly
        
        Entries : EpiGfilename -&gt; String
                  res -&gt; int
                  achr -&gt; int
                  sizeatres -&gt; int
                  NbEpi -&gt; int
        Return : Epimat -&gt; list
        &#34;&#34;&#34;
        Epimat=np.zeros((NbEpi,sizeatres))
        o=open(EpiGfilename,&#39;r&#39;)
        l=o.readline()
        while l:
                ls=l.split()
                if ls[0]==achr:
                        #force to scale bp cover in bin cover here
                        EpiV=int(ls[3])-1
                        b=np.float(ls[1])
                        e=np.float(ls[2])
                        begin=int(np.floor(b/res)) #force to cast for indexing error
                        end=int(np.floor(e/res)) #force to cast for indexing error
                        eC=end*res
                        bC=begin*res
                        val=1
                        if begin==end: #1 bin
                                Epimat[EpiV,begin]+=val*(e-b)
                        else:
                                if (end-begin)==1: #2 bin
                                        Epimat[EpiV,begin]+=val*(eC-b)
                                        Epimat[EpiV,end]+=val*(e-eC)
                                else: #more than 2 bin
                                        Epimat[EpiV,begin]+=val*(res-(b-bC))
                                        while begin&lt;end:
                                                Epimat[EpiV,begin]+=val*res
                                                begin+=1
                                        if (e-eC)&gt;0:
                                                Epimat[EpiV,begin]+=val*(e-eC) #here begin=end
                l=o.readline()
        o.close()
        return Epimat</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.OE"><code class="name flex">
<span>def <span class="ident">OE</span></span>(<span>D, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the OE matrix and return it
out : OE(D)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OE(D, printer=True):
        &#34;&#34;&#34;
        Calculate the OE matrix and return it
        out : OE(D)
        &#34;&#34;&#34;  
        i=0
        j=0
        L=len(D)

        if printer:
                bar = tqdm(range(1), desc=&#34;O/E &#34;)
        else:
                bar = range(1)
        
        for i in bar:
                pass
                
        while j&lt;L:
                thediag=np.diag(D,k=j)
                mtg=np.mean(thediag)
                if mtg == 0:
                        mtg = 1e-8
                while i&lt;(L-j):
                        v=D[i,i+j]/mtg
                        D[i,i+j]=v
                        D[i+j,i]=v
                        i+=1
                i=0
                j+=1
        return D</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.SCN"><code class="name flex">
<span>def <span class="ident">SCN</span></span>(<span>D, max_iter=10, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the SCN and return it
Out
: SCN(D)
Code version from Vincent Matthys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SCN(D, max_iter = 10, printer=True):
        &#34;&#34;&#34;
        Calculate the SCN and return it
        Out  : SCN(D)
        Code version from Vincent Matthys
        &#34;&#34;&#34;    
        # Iteration over max_iter

        if printer:
                bar = tqdm(range(max_iter), desc=&#34;SCN &#34;)
        else:
                bar = range(max_iter)

        for i in bar:        
                D /= np.maximum(1, D.sum(axis = 0))       
                D /= np.maximum(1, D.sum(axis = 1))    
                # To make matrix symetric again   
        return (D + D.T)/2 </code></pre>
</details>
</dd>
<dt id="HiCtoolbox.SVD"><code class="name flex">
<span>def <span class="ident">SVD</span></span>(<span>D)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the SVD and return the first eigenvector</p>
<p>out : SVD(D)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SVD(D):
        &#34;&#34;&#34;
        Calculate the SVD and return the first eigenvector
        
        out : SVD(D)
        &#34;&#34;&#34; 
        eigens_values,eigens_vectors = np.linalg.eig(D)
        return eigens_vectors[:,0]</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.bin1D"><code class="name flex">
<span>def <span class="ident">bin1D</span></span>(<span>anumpyarray, resolutionfrom, resolutionto)</span>
</code></dt>
<dd>
<div class="desc"><p>in : A numpy array , number of bin in raw and in col
out : the matrix binned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bin1D(anumpyarray, resolutionfrom, resolutionto):
        &#34;&#34;&#34;
        in : A numpy array , number of bin in raw and in col
        out : the matrix binned
        &#34;&#34;&#34;
        print(resolutionto,resolutionfrom)
        if resolutionto&gt;resolutionfrom:
                convertionfactor=np.ceil(resolutionto/resolutionfrom)
                s=anumpyarray.shape
                print(&#34;dimension du vecteur:&#34;,s)
                #has to be identical as result in other function like chrsizedict)
                newsizei=np.ceil(s[0]*resolutionfrom/resolutionto)
                newarray=np.zeros(int(newsizei))
                print(&#34;taille du vecteur appres rescale :&#34;,newarray.shape)
                i=0
                while i&lt;newsizei:
                        ifrom=int(i*convertionfactor)
                        ito=int((i+1)*convertionfactor)
                        if i==newsizei-1:
                                asum=np.sum(anumpyarray[ifrom:])
                        else:
                                asum=np.sum(anumpyarray[ifrom:ito])
                        newarray[i]=asum
                        i+=1
                return newarray
        elif resolutionto==resolutionfrom:
                print(&#34;no binning&#34;)
                return anumpyarray
        else:
                print(&#34;wrong resolution parameter in bin1D&#34;)</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.bin2d"><code class="name flex">
<span>def <span class="ident">bin2d</span></span>(<span>Data, p, q, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Data = input matrix
p,q rescaling factors
Written for sparse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bin2d(Data,p,q, printer=True):    
        &#34;&#34;&#34;   
        Data = input matrix
        p,q rescaling factors
        Written for sparse 
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Changing Resolution &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass

        n,m=np.shape(Data);
        s=(int(np.ceil(n/p)),int(np.ceil(m/q)))
        i,j,d = sparse.find(Data);
        i=np.int_(np.ceil(i/p))
        j=np.int_(np.ceil(j/q))
        M=sparse.csr_matrix((d,(i,j)))
        return M</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.bin2dfullmat"><code class="name flex">
<span>def <span class="ident">bin2dfullmat</span></span>(<span>anumpyarray, resolutionfrom, resolutionto)</span>
</code></dt>
<dd>
<div class="desc"><p>in : A numpy array , number of bin in raw and in col
out : the matrix binned
Written for full</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bin2dfullmat(anumpyarray, resolutionfrom, resolutionto):
        &#34;&#34;&#34;
        in : A numpy array , number of bin in raw and in col
        out : the matrix binned
        Written for full
        &#34;&#34;&#34;
        print(&#39;change of resolution from &#39;,resolutionfrom,&#39; to &#39;,resolutionto)
        if resolutionto&gt;resolutionfrom:
                convertionfactor=np.ceil(resolutionto/resolutionfrom)
                s=anumpyarray.shape
                print(&#34;Initial HiC size before binning:&#34;,s)
                #has to be identical as result in other function like chrsizedict)
                newsizei=np.ceil(s[0]*resolutionfrom/resolutionto)
                newsizej=np.ceil(s[1]*resolutionfrom/resolutionto)
                newarray=np.zeros((int(newsizei),int(newsizej)))
                print(&#34;HiC size after binning :&#34;,newarray.shape)
                i=0
                j=0
                while i&lt;newsizei:
                        while j&lt;newsizej:
                                ifrom=int(i*convertionfactor)
                                ito=int((i+1)*convertionfactor)
                                jfrom=int(j*convertionfactor)
                                jto=int((j+1)*convertionfactor)
                                if i==newsizei-1:
                                        asum=np.sum(anumpyarray[ifrom:,jfrom:jto])
                                elif j==newsizej-1:
                                        asum=np.sum(anumpyarray[ifrom:ito,jfrom:])
                                elif i==newsizei-1 and j==newsizej-1:
                                        asum=np.sum(anumpyarray[ifrom:,jfrom:])
                                else:
                                        asum=np.sum(anumpyarray[ifrom:ito,jfrom:jto])
                                newarray[i,j]=asum
                                newarray[j,i]=asum
                                j+=1
                        i+=1
                        j=0
                return newarray
        elif resolutionto==resolutionfrom:
                print(&#34;No binning&#34;)
                return anumpyarray
        else:
                print(&#34;Wrong resolution parameter&#34;)</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.buildColors"><code class="name flex">
<span>def <span class="ident">buildColors</span></span>(<span>EpiGfilename, chromosome_number, LENTEST, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Build the colors for the epigenetic marks</p>
<p>Entries : HiCfilename -&gt; String
chromosome_number -&gt; int
LENTEST -&gt; int
printer -&gt; boolean
Return : color_vec -&gt; list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildColors(EpiGfilename, chromosome_number, LENTEST, printer=True):
        &#34;&#34;&#34;
        Build the colors for the epigenetic marks
        
        Entries : HiCfilename -&gt; String
                  chromosome_number -&gt; int
                  LENTEST -&gt; int
                  printer -&gt; boolean
        Return : color_vec -&gt; list
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Loading Colors &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass
        color=pd.read_csv(EpiGfilename,delimiter=&#39;\t&#39;,header=None,names=[1,2,3,4])
        #Take only chr of interest
        color=color[color[1]==chromosome_number]
        #Number of color in the file
        number=color[4].max()
        #Build array at pb resolution LENchr * number of color
        color_vec=np.zeros((LENTEST,number+1), dtype=&#39;uint8&#39;) 
        i=0
        while i&lt;np.shape(color)[0]:
                color_vec[color[2].iloc[i]:color[3].iloc[i],color[4].iloc[i]]=1
                i+=1
        return color_vec</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.buildMatrix"><code class="name flex">
<span>def <span class="ident">buildMatrix</span></span>(<span>HiCfilename, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Build the matrix from the HiC data</p>
<p>Entries : HiCfilename -&gt; String
printer -&gt; boolean
Return : A -&gt; list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildMatrix(HiCfilename, printer=True):
    &#34;&#34;&#34;
    Build the matrix from the HiC data
    
    Entries : HiCfilename -&gt; String
              printer -&gt; boolean
    Return : A -&gt; list
    &#34;&#34;&#34;
    if printer:
        bar = tqdm(range(1), desc=&#34;Loading Matrix &#34;)
    else:
        bar = range(1)

    for i in bar:
        pass
    try:
        A=np.loadtxt(HiCfilename)
        A=np.int_(A)
    except:
        print(&#34;Data was not correctly downloaded, please delete the folder and relaunch the main.py&#34;)
    
    #Build array at pb resolution
    A=np.concatenate((A,np.transpose(np.array([A[:,1],A[:,0],A[:,2]]))), axis=0)
    A = sparse.coo_matrix( (A[:,2], (A[:,0],A[:,1])))
    return A</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.expr_repr_scoring"><code class="name flex">
<span>def <span class="ident">expr_repr_scoring</span></span>(<span>color_bins, marks, scores)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the expression repression score and return it</p>
<p>Entries : color_bins -&gt; list
marks -&gt; list
scores -&gt; list
Return : float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expr_repr_scoring(color_bins, marks, scores):
        &#34;&#34;&#34;
        Calculate the expression repression score and return it
        
        Entries : color_bins -&gt; list
                  marks -&gt; list
                  scores -&gt; list
        Return : float
        &#34;&#34;&#34;
        output = color_bins[:,0].toarray() #only zeros
        for i in range(len(marks)):
                mark = marks[i]
                score = scores[i]
                X = color_bins[:,mark].toarray()
                output+=X*score

        return output</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.fastFloyd"><code class="name flex">
<span>def <span class="ident">fastFloyd</span></span>(<span>contact, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>out : FF(contact)
Code version from Vincent Matthys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fastFloyd(contact, printer=True):
        &#34;&#34;&#34;
        out : FF(contact)
        Code version from Vincent Matthys
        &#34;&#34;&#34;      
        n = contact.shape[0]    
        shortest = contact    

        if printer:
                bar = tqdm(range(n), desc=&#34;Fast Floyd &#34;)
        else:
                bar = range(n)

        for k in bar:        
                i2k = np.tile(shortest[k,:], (n, 1))        
                k2j = np.tile(shortest[:, k], (n, 1)).T        
                shortest = np.minimum(shortest, i2k + k2j)    
        return shortest</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.filteramat"><code class="name flex">
<span>def <span class="ident">filteramat</span></span>(<span>Hicmat, Filterextremum=True, factor=1.5, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>in : a HiCmat without any transformation, factor of reduction
out : the HiCmatreduce,thevector of his transformation
THE filter part from the main in one function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filteramat(Hicmat, Filterextremum=True, factor=1.5, printer=True):
        &#34;&#34;&#34;
        in : a HiCmat without any transformation, factor of reduction
        out : the HiCmatreduce,thevector of his transformation
        THE filter part from the main in one function
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Matrix Filtering &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass
        Hicmatreduce=Hicmat
        #first step : filter empty bin
        sumHicmat=Hicmat.sum(axis = 0)
        segmenter1=sumHicmat&gt;0
        A=np.where(segmenter1)
        Hicmatreduce=Hicmatreduce[A[1],:]
        Hicmatreduce=Hicmatreduce[:,A[1]]
        if Filterextremum:
                #second step : filter lower bin
                sumHicmat=np.sum(Hicmatreduce,0)
                msum=np.mean(sumHicmat)
                mstd=np.std(sumHicmat)
                mini = msum-mstd*factor
                maxi = msum+mstd*factor
                #Make the bolean condition
                newcond=mini &lt; sumHicmat
                newcond2=sumHicmat &lt; maxi
                newcond=np.logical_and(newcond,newcond2)
                B=np.where(newcond)
                #Filter
                Hicmatreduce=Hicmatreduce[B[1],:]
                Hicmatreduce=Hicmatreduce[:,B[1]]
                segmenter1=A[1][B[1]] #Create the binsaved index
        return Hicmatreduce,segmenter1</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.filtering"><code class="name flex">
<span>def <span class="ident">filtering</span></span>(<span>Hicmat, factor=1.5, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter the matrix and return the matrix filtered and the list of indexs removed</p>
<p>Entries : Hicmat -&gt; list
factor -&gt; float
printer -&gt; boolean
Return : Hicmatreduce -&gt; list
segmenter1 -&gt; list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filtering(Hicmat,factor=1.5, printer=True):
        &#34;&#34;&#34;
        Filter the matrix and return the matrix filtered and the list of indexs removed
        
        Entries : Hicmat -&gt; list
                  factor -&gt; float
                  printer -&gt; boolean
        Return : Hicmatreduce -&gt; list
                 segmenter1 -&gt; list
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Filtering &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass

        Filterextremum=True
        Hicmatreduce=Hicmat
        #first step : filter empty bin
        sumHicmat=Hicmat.sum(axis = 0)
        segmenter1=sumHicmat&gt;0
        A=np.where(segmenter1)
        Hicmatreduce=Hicmatreduce[A[1],:]
        Hicmatreduce=Hicmatreduce[:,A[1]]
        if Filterextremum:
                #second step : filter lower bin
                sumHicmat=np.sum(Hicmatreduce,0)
                msum=np.mean(sumHicmat)
                mstd=np.std(sumHicmat)
                mini = msum-mstd*factor
                maxi = msum+mstd*factor
                #Make the bolean condition
                newcond=mini &lt; sumHicmat
                newcond2=sumHicmat &lt; maxi
                newcond=np.logical_and(newcond,newcond2)
                B=np.where(newcond)
                #Filter
                Hicmatreduce=Hicmatreduce[B[1],:]
                Hicmatreduce=Hicmatreduce[:,B[1]]
                segmenter1=A[1][B[1]] #Create the binsaved index
        return Hicmatreduce,segmenter1</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.gaussianHMM"><code class="name flex">
<span>def <span class="ident">gaussianHMM</span></span>(<span>vector, nb_comp=2, n_iter=100)</span>
</code></dt>
<dd>
<div class="desc"><p>generate a simple hmm to have compartment on correlation map
Return the model of the hmm and the states of the prediction at given N</p>
<p>Entries : vector -&gt; list
nb_comp -&gt; int
n_iter -&gt; int
Return : labels_list -&gt; list
scores_list -&gt; list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaussianHMM(vector, nb_comp=2, n_iter=100):
        &#34;&#34;&#34;
        generate a simple hmm to have compartment on correlation map
        Return the model of the hmm and the states of the prediction at given N
        
        Entries : vector -&gt; list
                  nb_comp -&gt; int
                  n_iter -&gt; int
        Return : labels_list -&gt; list
                 scores_list -&gt; list
        &#34;&#34;&#34;
        # Run Gaussian HMM
        model = hmm.GaussianHMM(nb_comp, &#34;tied&#34;,n_iter=n_iter)
        model.fit(vector)
        labels = model.predict(vector) #etats/compartiments
        score = model.score(vector)

        return labels, score</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.multiplegaussianHMM"><code class="name flex">
<span>def <span class="ident">multiplegaussianHMM</span></span>(<span>vector, nb_comp_max=16, n_iter=100)</span>
</code></dt>
<dd>
<div class="desc"><p>generate the hmms of each compartment on correlation map
Return the model of all hmm and the states of the prediction at given N</p>
<p>Entries : vector -&gt; list
nb_comp_max -&gt; int
n_iter -&gt; int
Return : labels_list -&gt; list
scores_list -&gt; list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiplegaussianHMM(vector, nb_comp_max=16, n_iter=100):
        &#34;&#34;&#34;
        generate the hmms of each compartment on correlation map
        Return the model of all hmm and the states of the prediction at given N
        
        Entries : vector -&gt; list
                  nb_comp_max -&gt; int
                  n_iter -&gt; int
        Return : labels_list -&gt; list
                 scores_list -&gt; list
        &#34;&#34;&#34;
        labels_list = []
        scores_list = []
        for i in tqdm (range(2, nb_comp_max), desc=&#34;Finding Compartments with HMM &#34;):
                labels, score = gaussianHMM(vector, i, n_iter=n_iter)
                labels_list.append(labels)
                scores_list.append(score)

        return labels_list, scores_list</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.plotter"><code class="name flex">
<span>def <span class="ident">plotter</span></span>(<span>data2D, nameFig='Plot', plotType='Matrix', cmap='hot_r', vmin=None, vmax=None, jupyter=False, nameFile='Plot.pdf', centro_start=None, centro_end=None, Data_type='Contact')</span>
</code></dt>
<dd>
<div class="desc"><p>Plotter used in the analysis</p>
<p>Entries : data2D -&gt; list
nameFig -&gt; String
plotType -&gt; String
cmap -&gt; String
vmin -&gt; float
vmax -&gt; float
jupyter -&gt; boolean
nameFile -&gt; String
centro_start -&gt; int
centro_end -&gt; int
Data_type -&gt; String</p>
<p>Make the various following plots :
- Matrix plot
- AB Compartments plot
- Density plot
- HMM Score plot
- All Results plot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotter(data2D, nameFig=&#34;Plot&#34;, plotType=&#34;Matrix&#34;, cmap=&#34;hot_r&#34;, vmin=None, vmax=None, jupyter=False, nameFile=&#34;Plot.pdf&#34;, centro_start=None, centro_end=None, Data_type=&#39;Contact&#39;):
    &#34;&#34;&#34;
    Plotter used in the analysis
    
    Entries : data2D -&gt; list
              nameFig -&gt; String
              plotType -&gt; String
              cmap -&gt; String
              vmin -&gt; float
              vmax -&gt; float
              jupyter -&gt; boolean
              nameFile -&gt; String
              centro_start -&gt; int
              centro_end -&gt; int
              Data_type -&gt; String
    
    Make the various following plots :
    - Matrix plot
    - AB Compartments plot
    - Density plot
    - HMM Score plot
    - All Results plot
    &#34;&#34;&#34;
    if plotType == &#34;Matrix&#34;:
        custom_params = {&#34;axes.spines.right&#34;: False, 
                         &#34;axes.spines.top&#34;: False}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)
        fig = plt.figure()
        fig.set_dpi(300)
        im = plt.imshow(data2D, cmap=cmap, vmin=vmin, vmax=vmax)
        plt.colorbar(im, drawedges=False)
        plt.xlabel(&#34;Position&#34;)
        plt.ylabel(&#34;Position&#34;)
        plt.title(nameFig)

    elif plotType == &#34;AB&#34;:
        custom_params = {&#34;axes.spines.right&#34;: False, 
                         &#34;axes.spines.top&#34;: False,}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)
        x = np.arange(0.0, np.shape(data2D)[0], 1)
        y = data2D
        fig, ax = plt.subplots()
        fig.set_dpi(300)
        ax.fill_between(x, y, where=(data2D&gt;0), color=&#39;red&#39;)
        ax.axhline(0, color=&#34;black&#34;, linewidth=0.75)
        ax.fill_between(x, y, where=(data2D&lt;0), color=&#39;blue&#39;)
        plt.axvspan(centro_start, centro_end, facecolor=&#39;red&#39;, alpha=0.2)
        plt.xlabel(&#34;Position&#34;)
        plt.ylabel(&#34;Activation&#34;)
        plt.title(nameFig)

    elif plotType == &#34;Density&#34;: #Density plot
        custom_params = {&#34;axes.spines.right&#34;: False, 
                         &#34;axes.spines.top&#34;: False}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)
        x = np.arange(0,len(data2D))
        y = data2D
        fig = plt.figure()
        fig.set_dpi(300)
        plt.plot(x, y, color=&#39;blue&#39;, alpha=1, linewidth=0.1)
        plt.axvspan(centro_start, centro_end, facecolor=&#39;red&#39;, alpha=0.2)
        plt.xlabel(&#34;Position&#34;)
        plt.ylabel(&#34;Density&#34;)
        plt.title(nameFig)

    elif plotType == &#34;HMMScore&#34;:
        custom_params = {&#34;axes.spines.right&#34;: False, &#34;axes.spines.top&#34;: False}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)
        x = np.arange(2,16)
        y = data2D
        fig = plt.figure()
        fig.set_dpi(300)
        plt.plot(x, y, color=&#39;blue&#39;, alpha=0.4)
        best = 2
        if (Data_type==&#39;Contact&#39;):
            threshold = 1
        elif Data_type==&#39;Epigenetic&#39;:
            threshold = 0.5
        for i in range(1,len(data2D)):
            temp = ((data2D[i]-data2D[i-1])/np.abs(data2D[i]))*100
            if temp &gt;= threshold:
                best += 1
            else: 
                break
        plt.scatter(best, data2D[best-2], alpha=1, color=&#39;red&#39;, label=&#34;predicted number of compartments : &#34; + str(best))
        plt.xlabel(&#34;Number of compartments&#34;)
        plt.ylabel(&#34;HMM Score&#34;)
        plt.legend(loc=&#39;upper left&#39;)
        plt.title(nameFig)

    elif plotType == &#34;Barcode&#34;:
        custom_params = {&#34;axes.spines.left&#34;: False, 
                         &#34;axes.spines.right&#34;: False, 
                         &#34;axes.spines.top&#34;: False}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)
        pixel_per_bar = 1
        dpi = 100
        fig = plt.figure(figsize=(len(data2D) * pixel_per_bar / dpi, 2))
        fig.set_dpi(300)
        ax = fig.add_axes([0, 0, 1, 1])
        ax.imshow(data2D.reshape(1, -1), cmap=&#39;bwr&#39;, aspect=&#39;auto&#39;, interpolation=&#39;nearest&#39;)
        ax.axes.get_yaxis().set_visible(False)
        plt.xlabel(&#34;Position&#34;)
        plt.title(nameFig)

    elif plotType == &#34;Visualization&#34;:
        [barcode, corr, density] = data2D
        fig = plt.figure(constrained_layout=True)
        fig.set_dpi(300)
        gs = fig.add_gridspec(ncols=2, 
                              nrows=2,
                              width_ratios=[10, 6.25], 
                              wspace=0.,
                              hspace=0., 
                              height_ratios=[1, 13])
        custom_params = {&#34;axes.spines.right&#34;: False, 
                         &#34;axes.spines.top&#34;: False}
        sns.set_theme(style=&#34;ticks&#34;, rc=custom_params)

        #Barcode
        f_ax1 = fig.add_subplot(gs[0, 0])
        f_ax1.set_xlim([0,np.shape(barcode)[0]])
        f_ax1.grid(False)
        f_ax1.set(yticklabels=[], xticklabels=[])
        f_ax1.tick_params(left=False, right=False)
        x = np.arange(0, np.shape(barcode)[0], 1)
        f_ax1.set_title(nameFig, x=0.5, y=1.2)
        f_ax1.imshow(barcode.reshape(1, -1), cmap=&#39;bwr&#39;, aspect=&#39;auto&#39;, interpolation=&#39;nearest&#39;)

        #Correlation Matrix
        f_ax2 = fig.add_subplot(gs[1, 0])
        im = f_ax2.imshow(corr, cmap=&#39;seismic&#39;, vmin=-np.amax(corr), vmax=np.amax(corr))
        f_ax2.grid(False)
        plt.colorbar(im, location=&#39;left&#39;)

        #Gene density
        f_ax3 = fig.add_subplot(gs[1, 1])
        f_ax3.axis(&#39;off&#39;)
        x = density
        y = np.flip(np.arange(0,np.shape(density)[0]))
        f_ax3.axhspan(np.shape(density)[0]-centro_start, np.shape(density)[0]-centro_end, facecolor=&#39;red&#39;, alpha=0.2)
        f_ax3.plot(x, y, color=&#39;blue&#39;, alpha=1, linewidth=0.1)

    if jupyter:
        plt.show()
    else:
        plt.savefig(nameFile)
    plt.clf()</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.sammon"><code class="name flex">
<span>def <span class="ident">sammon</span></span>(<span>x, n, display=2, inputdist='raw', maxhalves=20, maxiter=500, tolfun=1e-09, init='default')</span>
</code></dt>
<dd>
<div class="desc"><p>Perform Sammon mapping on dataset x</p>
<p>y = sammon(x) applies the Sammon nonlinear mapping procedure on
multivariate data x, where each row represents a pattern and each column
represents a feature.
On completion, y contains the corresponding
co-ordinates of each point on the map.
By default, a two-dimensional
map is created.
Note if x contains any duplicated rows, SAMMON will
fail (ungracefully). </p>
<p>[y,E] = sammon(x) also returns the value of the cost function in E (i.e.
the stress of the mapping).</p>
<p>An N-dimensional output map is generated by y = sammon(x,n) .</p>
<p>A set of optimisation options can be specified using optional
arguments, y = sammon(x,n,[OPTS]):</p>
<p>maxiter
- maximum number of iterations
tolfun
- relative tolerance on objective function
maxhalves
- maximum number of step halvings
input
- {'raw','distance'} if set to 'distance', X is
interpreted as a matrix of pairwise distances.
display
- 0 to 2. 0 least verbose, 2 max verbose.
init
- {'pca', 'cmdscale', random', 'default'}
default is 'pca' if input is 'raw',
'msdcale' if input is 'distance'</p>
<p>The default options are retrieved by calling sammon(x) with no
parameters.</p>
<p>File
: sammon.py
Date
: 18 April 2014
Authors
: Tom J. Pollard (tom.pollard.11@ucl.ac.uk)
: Ported from MATLAB implementation by
Gavin C. Cawley and Nicola L. C. Talbot</p>
<p>Description : Simple python implementation of Sammon's non-linear
mapping algorithm [1].</p>
<p>References
: [1] Sammon, John W. Jr., "A Nonlinear Mapping for Data
Structure Analysis", IEEE Transactions on Computers,
vol. C-18, no. 5, pp 401-409, May 1969.</p>
<p>Copyright
: (c) Dr Gavin C. Cawley, November 2007.</p>
<p>This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sammon(x, n, display = 2, inputdist = &#39;raw&#39;, maxhalves = 20, maxiter = 500, tolfun = 1e-9, init = &#39;default&#39;):


    &#34;&#34;&#34;Perform Sammon mapping on dataset x

    y = sammon(x) applies the Sammon nonlinear mapping procedure on
    multivariate data x, where each row represents a pattern and each column
    represents a feature.  On completion, y contains the corresponding
    co-ordinates of each point on the map.  By default, a two-dimensional
    map is created.  Note if x contains any duplicated rows, SAMMON will
    fail (ungracefully). 

    [y,E] = sammon(x) also returns the value of the cost function in E (i.e.
    the stress of the mapping).

    An N-dimensional output map is generated by y = sammon(x,n) .

    A set of optimisation options can be specified using optional
    arguments, y = sammon(x,n,[OPTS]):

       maxiter        - maximum number of iterations
       tolfun         - relative tolerance on objective function
       maxhalves      - maximum number of step halvings
       input          - {&#39;raw&#39;,&#39;distance&#39;} if set to &#39;distance&#39;, X is 
                        interpreted as a matrix of pairwise distances.
       display        - 0 to 2. 0 least verbose, 2 max verbose.
       init           - {&#39;pca&#39;, &#39;cmdscale&#39;, random&#39;, &#39;default&#39;}
                        default is &#39;pca&#39; if input is &#39;raw&#39;, 
                        &#39;msdcale&#39; if input is &#39;distance&#39;

    The default options are retrieved by calling sammon(x) with no
    parameters.

    File        : sammon.py
    Date        : 18 April 2014
    Authors     : Tom J. Pollard (tom.pollard.11@ucl.ac.uk)
                : Ported from MATLAB implementation by 
                  Gavin C. Cawley and Nicola L. C. Talbot

    Description : Simple python implementation of Sammon&#39;s non-linear
                  mapping algorithm [1].

    References  : [1] Sammon, John W. Jr., &#34;A Nonlinear Mapping for Data
                  Structure Analysis&#34;, IEEE Transactions on Computers,
                  vol. C-18, no. 5, pp 401-409, May 1969.

    Copyright   : (c) Dr Gavin C. Cawley, November 2007.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

    &#34;&#34;&#34;

    # Create distance matrix unless given by parameters
    if inputdist == &#39;distance&#39;:
        D = x
        if init == &#39;default&#39;:
            init = &#39;cmdscale&#39;
    else:
        D = distance.cdist(x, x)
        if init == &#39;default&#39;:
            init = &#39;pca&#39;

    if inputdist == &#39;distance&#39; and init == &#39;pca&#39;:
        raise ValueError(&#34;Cannot use init == &#39;pca&#39; when inputdist == &#39;distance&#39;&#34;)

    if np.count_nonzero(np.diagonal(D)) &gt; 0:
        raise ValueError(&#34;The diagonal of the dissimilarity matrix must be zero&#34;)

    # Remaining initialisation
    N = x.shape[0]
    scale = 0.5 / D.sum()
    D = D + np.eye(N)     

    if np.count_nonzero(D&lt;=0) &gt; 0:
        raise ValueError(&#34;Off-diagonal dissimilarities must be strictly positive&#34;)   

    Dinv = 1 / D
    if init == &#39;pca&#39;:
        [UU,DD,_] = np.linalg.svd(x)
        y = UU[:,:n]*DD[:n] 
    elif init == &#39;cmdscale&#39;:
        from cmdscale import cmdscale
        y,e = cmdscale(D)
        y = y[:,:n]
    else:
        y = np.random.normal(0.0,1.0,[N,n])
    one = np.ones([N,n])
    d = distance.cdist(y,y) + np.eye(N)
    dinv = 1. / d
    delta = D-d 
    E = ((delta**2)*Dinv).sum()

    # Get on with it
    for i in range(maxiter):

        # Compute gradient, Hessian and search direction (note it is actually
        # 1/4 of the gradient and Hessian, but the step size is just the ratio
        # of the gradient and the diagonal of the Hessian so it doesn&#39;t
        # matter).
        delta = dinv - Dinv
        deltaone = np.dot(delta,one)
        g = np.dot(delta,y) - (y * deltaone)
        dinv3 = dinv ** 3
        y2 = y ** 2
        H = np.dot(dinv3,y2) - deltaone - np.dot(2,y) * np.dot(dinv3,y) + y2 * np.dot(dinv3,one)
        s = -g.flatten(order=&#39;F&#39;) / np.abs(H.flatten(order=&#39;F&#39;))
        y_old    = y

        # Use step-halving procedure to ensure progress is made
        for j in range(maxhalves):
            s_reshape = np.reshape(s, (-1,n),order=&#39;F&#39;)
            y = y_old + s_reshape
            d = distance.cdist(y, y) + np.eye(N)
            dinv = 1 / d
            delta = D - d
            E_new = ((delta**2)*Dinv).sum()
            if E_new &lt; E:
                break
            else:
                s = 0.5*s

        # Bomb out if too many halving steps are required
        if j == maxhalves-1:
            print(&#39;Warning: maxhalves exceeded. Sammon mapping may not converge...&#39;)

        # Evaluate termination criterion
        if abs((E - E_new) / E) &lt; tolfun:
            if display:
                print(&#39;TolFun exceeded: Optimisation terminated&#39;)
            break

        # Report progress
        E = E_new
        if display &gt; 1 and printer:
            print(&#39;epoch = %d : E = %12.10f&#39;% (i+1, E * scale))

    if i == maxiter-1:
        print(&#39;Warning: maxiter exceeded. Sammon mapping may not have converged...&#39;)

    # Fiddle stress to match the original Sammon paper
    E = E * scale
    
    return [y,E]</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.similarity_score"><code class="name flex">
<span>def <span class="ident">similarity_score</span></span>(<span>val_data, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the similarity score and return it</p>
<p>Entries : val_data -&gt; list
data -&gt; list
Return : float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def similarity_score(val_data, data):
        &#34;&#34;&#34;
        Calculate the similarity score and return it
        
        Entries : val_data -&gt; list
                  data -&gt; list
        Return : float
        &#34;&#34;&#34;
        cnt = 0
        for i in range(np.shape(data)[0]):
                if val_data[i] == data[i]:
                        cnt += 1

        similarity = cnt/np.shape(data)[0] * 100
        
        return round(similarity, 3)</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.unfiltering"><code class="name flex">
<span>def <span class="ident">unfiltering</span></span>(<span>binsaved, contact_map, shape, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Unfilter the matrix and return the matrix unfiltered</p>
<p>Entries : binsaved -&gt; list
contact_map -&gt; list
shape -&gt; list
printer -&gt; boolean
Return : unfiltered_map -&gt; list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unfiltering(binsaved, contact_map, shape, printer=True):
        &#34;&#34;&#34;
        Unfilter the matrix and return the matrix unfiltered
        
        Entries : binsaved -&gt; list
                  contact_map -&gt; list
                  shape -&gt; list
                  printer -&gt; boolean
        Return : unfiltered_map -&gt; list
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Unfiltering &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass

        unfiltered_map = contact_map
        binunsaved = []
        for i in range(shape[0]):
                if ((i in binsaved) == False):
                        binunsaved.append(i)
        for i in binunsaved:
                unfiltered_map = np.insert(unfiltered_map, i, 0, axis= 0)
                unfiltered_map = np.insert(unfiltered_map, i, 0, axis= 1)
        return unfiltered_map</code></pre>
</details>
</dd>
<dt id="HiCtoolbox.writePDB"><code class="name flex">
<span>def <span class="ident">writePDB</span></span>(<span>fnameout, value, EpiValue, printer=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a PDB file from values</p>
<p>Entries : fnameout -&gt; String
value -&gt; int
EpiValue -&gt; list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writePDB(fnameout, value, EpiValue, printer=True):
        &#34;&#34;&#34;
        Write a PDB file from values
        
        Entries : fnameout -&gt; String
                  value -&gt; int
                  EpiValue -&gt; list  
        &#34;&#34;&#34;
        if printer:
                bar = tqdm(range(1), desc=&#34;Writing PDB &#34;)
        else:
                bar = range(1)

        for i in bar:
                pass
        Sh=np.shape(value)
        #out
        fout=open(fnameout,&#39;w&#39;)
        i=1
        while i&lt;=Sh[0]:
                S=&#34;{:6s}{:5d} {:^4s}{:1s}{:3s} {:1s}{:4d}{:1s}   {:8.3f}{:8.3f}{:8.3f}{:6.2f}{:6.2f}          {:&gt;2s}{:2s}&#34; #PDB format in python
                #print(&#34;here&#34;,value[i-1,0],value[i-1,1],EpiValue[i-1])
                S=S.format(&#39;ATOM&#39;,i,&#39;CA&#39;,&#39;&#39;,&#39;ALA&#39;,&#39;A&#39;,i,&#39;&#39;,float(value[i-1,0]),float(value[i-1,1]),float(value[i-1,2]),1,float(EpiValue[i-1]),&#39;C&#39;,&#39;&#39;)
                #print(S)
                fout.write(S+&#34;\n&#34;)
                i+=1
        fout.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="HiCtoolbox.Corr" href="#HiCtoolbox.Corr">Corr</a></code></li>
<li><code><a title="HiCtoolbox.EpiGbyres" href="#HiCtoolbox.EpiGbyres">EpiGbyres</a></code></li>
<li><code><a title="HiCtoolbox.OE" href="#HiCtoolbox.OE">OE</a></code></li>
<li><code><a title="HiCtoolbox.SCN" href="#HiCtoolbox.SCN">SCN</a></code></li>
<li><code><a title="HiCtoolbox.SVD" href="#HiCtoolbox.SVD">SVD</a></code></li>
<li><code><a title="HiCtoolbox.bin1D" href="#HiCtoolbox.bin1D">bin1D</a></code></li>
<li><code><a title="HiCtoolbox.bin2d" href="#HiCtoolbox.bin2d">bin2d</a></code></li>
<li><code><a title="HiCtoolbox.bin2dfullmat" href="#HiCtoolbox.bin2dfullmat">bin2dfullmat</a></code></li>
<li><code><a title="HiCtoolbox.buildColors" href="#HiCtoolbox.buildColors">buildColors</a></code></li>
<li><code><a title="HiCtoolbox.buildMatrix" href="#HiCtoolbox.buildMatrix">buildMatrix</a></code></li>
<li><code><a title="HiCtoolbox.expr_repr_scoring" href="#HiCtoolbox.expr_repr_scoring">expr_repr_scoring</a></code></li>
<li><code><a title="HiCtoolbox.fastFloyd" href="#HiCtoolbox.fastFloyd">fastFloyd</a></code></li>
<li><code><a title="HiCtoolbox.filteramat" href="#HiCtoolbox.filteramat">filteramat</a></code></li>
<li><code><a title="HiCtoolbox.filtering" href="#HiCtoolbox.filtering">filtering</a></code></li>
<li><code><a title="HiCtoolbox.gaussianHMM" href="#HiCtoolbox.gaussianHMM">gaussianHMM</a></code></li>
<li><code><a title="HiCtoolbox.multiplegaussianHMM" href="#HiCtoolbox.multiplegaussianHMM">multiplegaussianHMM</a></code></li>
<li><code><a title="HiCtoolbox.plotter" href="#HiCtoolbox.plotter">plotter</a></code></li>
<li><code><a title="HiCtoolbox.sammon" href="#HiCtoolbox.sammon">sammon</a></code></li>
<li><code><a title="HiCtoolbox.similarity_score" href="#HiCtoolbox.similarity_score">similarity_score</a></code></li>
<li><code><a title="HiCtoolbox.unfiltering" href="#HiCtoolbox.unfiltering">unfiltering</a></code></li>
<li><code><a title="HiCtoolbox.writePDB" href="#HiCtoolbox.writePDB">writePDB</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>